==============================================

(defcustom mtg-language-list

  '(
    )

  "Language names.

`listp' of `symbolp's.

Languages into which cards have been translated."

  :type '(repeat (symbol :tag "Language Name"))

  :safe #'listp
  :group 'mtg)

;;----------------------------------------------;;

(defcustom mtg-language-alist

  (list (mtg-language-create :language ' :abbreviation ')
        (mtg-language-create :language ' :abbreviation ')
        )

  "Language metadata (abbreviations and endonyms).

`listp' of `mtg-language-p's:

â€¢ each â€˜:languageâ€™ should be in `mtg-language-list'."

  :type '(repeat (symbol :tag "Language Info"))

  :safe #'listp
  :group 'mtg)

==============================================

;; Package-Requires: ((emacs "25") (json "1.4"))

;;----------------------------------------------;;

(cl-defun make-mtg-symbol (&key symbol abbreviation (image nil) (char nil))

  "Make an `mtg-symbol'. 

A Smart Constructor â€” validation & defaulting.

Inputs:

â€¢ SYMBOL       â€” a `symbolp'.
â€¢ ABBREVIATION â€” a `symbolp'.
â€¢ IMAGE        â€” an optional `imagep', or `symbolp' thereof.
â€¢ CHAR         â€” an optional `characterp', or `symbolp' thereof.

Examples:

â€¢ M-: (make-mtg-symbol :symbol 'blue-mana :abbreviation 'u :char ?ðŸŒ¢)
   â‡’ #s(mtg-symbol blue-mana u nil 127778)"

  (let* ((SYMBOL       symbol)
         (ABBREVIATION abbreviation)
         (IMAGE        image)
         (CHAR         char)
         )

  (mtg-symbol-create :symbol       SYMBOL
                     :abbreviation ABBREVIATION
                     :image        IMAGE
                     :char         CHAR)))

==============================================

(defun mtg-company (command &optional arg &rest _)

  "Company Backend for MTG Cards.

Inputs:

â€¢ COMMAND â€” a `symbolp'.
  The Company-Command.
â€¢ ARG â€” an `integerp'.
  A Prefix-Argument."

  (case command

    (interactive
     (company-begin-backend 'company-mtg))

    (init    
     (mtg-initialize-cards-by-name-table))

    (prefix
     (mtg-company-grab-card-name))

    (candidates
     ())

    (ignore-case
     'keep-prefix)))

==============================================


(defun mtg-company-grab-card-name ()

  "Grab the â€˜mtg-card-nameâ€™ before `point'.

Idiomatic card names:

â€¢ should (mostly) have capitalized words;
â€¢ may include lowercase articles;
â€¢ may have some punctuation characters (hyphen, apostrophe, colon).

If point is at the end of a word, return it.
Otherwise, if point is not inside a symbol, return an empty string."

  (pcase-let* ((BEG-POINT . END-POINT)
               (bounds-of-thing-at-point 'mtg-card-name))
    (POINT (point))
    (TEXT (buffer-substring BEG-POINT POINT))
    )


  (if (looking-at "\\>")

      (buffer-substring (point) (save-excursion (skip-backward mtg-syntax-card-name-charset-regexp) (point)))

    (unless (and (char-after) (eq (char-syntax (char-after)) ?w))

      "")))

  ()))

==============================================



(unless (bound-and-true-p mtg-cards-names-vector)

  (defvar mtg-cards-names-vector mtg-company-cards-names-vector

    "MTG Card Names (see `mtg-company-cards-names-vector')."))


==============================================

(defun mtg-company-initialize-card-names (force)

  "Initialize the MTG Card Name store.

Inputs:

â€¢ FORCE â€” a `booleanp'.

Effects:

â€¢ Modifies `mtg-company-card-names-vector'."

  (let* ((INITIALIZE? (or force
                          (not (bound-and-true-p mtg-company-card-names-vector))))
         )

    (when INITIALIZE?
      ())))

==============================================


(defun mtg-company-card-names-trie ()

  "Return all (known/valid) MTG Cards Naes.

Output:

â€¢ a `vectorp' of `stringp's."

  (if (bound-and-true-p mtg-card-names-vector)
      mtg-card-names-vector
    mtg-company-card-names-vector))

;;----------------------------------------------;;

(defun mtg-company-card-names-trie ()

  "Return all (known/valid) MTG Cards Naes.

Output:

â€¢ a `vectorp' of `stringp's."

  (if (bound-and-true-p mtg-card-names-vector)
      mtg-card-names-vector
    mtg-company-card-names-vector))


;;----------------------------------------------;;

(defun mtg-company-complete-card-name (prefix)

  "Complete PREFIX as an MTG Card Name.

Inputs:

â€¢ PREFIX â€” a `stringp'.

Output:

â€¢ a `listp' of `stringp's.

See:

â€¢ thing â€˜mtg-card-nameâ€™."

  (let* ((PREFIX        (or prefix ""))
         (POSSIBILITIES (mtg-company-card-names))
         (CANDIDATES    (complete PREFIX POSSIBILITIES))
         )

    CANDIDATES))

==============================================

(cl-defun mtg-company/radix-tree/suffixes (trie prefix &key ignore-case)

  "Return a `radix-tree-p' from WORDS.

Inputs:

â€¢ TRIE        â€” a `radix-tree-p'.
â€¢ PREFIX      â€” a `stringp'.
â€¢ IGNORE-CASE â€” a `booleanp'.

Examples:

â€¢ M-: (mtg-company/radix-tree/suffixes (mtg-company/radix-tree/from-seq (list \"application\" \"appetizer\" \"applicative\" \"apple\")) \"appli\" :ignore-case t)
    â†’ '(\"application\" \"applicative\")"

  (let* ((SET (make-hash-table))
         )

    (radix-tree-iter-mappings
     trie

     (lambda (k v)
       (message "%s â‡’ %s (%s)" k v prefix)
       (when (string-prefix-p prefix k ignore-case)
         (puthash k t SET)))

    (hash-table-keys SET))))

;; ^ M-: (mtg-company/radix-tree/suffixes (mtg-company/radix-tree/from-seq '("application" "appetizer" "applicative" "apple")) "appli" :ignore-case t)
;;     â‡’ '("application" "applicative")
;;
;;   M-: (string-prefix-p "appli" "application" t)
;;     â‡’ t
;;

==============================================



==============================================