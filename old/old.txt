=================================================

(defvar mtg-company-card-name-characters

  (seq-sort #'< (seq-uniq (string-join (seq-into (mtg-company-card-names) 'list) ""))))

M-: (apply #'string mtg-company-card-name-characters)
;; " !\"',-.01:?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√†√°√¢√©√≠√∂√∫√ª"

(defvar mtg-company-card-name-words

  (seq-sort #'string<
            (seq-uniq
             (seq-mapcat #'split-string
                         (mtg-company-card-names)
                         'list))))

(defvar mtg-company-card-name-articles

  (seq-sort #'string>
            (seq-uniq
             (seq-filter (lambda (word) (not (s-capitalized-p word)))
                         (seq-mapcat #'split-string
                                     (mtg-company-card-names)
                                     'list)))))

M-: (describe-variable 'mtg-company-card-name-articles)
;;  ("a" "an" "and" "as" "at" "but" "by" "en-Dal" "en-Kor" "en-Vec" "for" "from" "il-Dal" "il-Kor" "il-Vec" "in" "into" "le" "of" "on" "or" "the" "to" "upon" "with")

=================================================

(defcustom mtg-language-list

  '(
    )

  "Language names.

`listp' of `symbolp's.

Languages into which cards have been translated."

  :type '(repeat (symbol :tag "Language Name"))

  :safe #'listp
  :group 'mtg)

;;----------------------------------------------;;

(defcustom mtg-language-alist

  (list (mtg-language-create :language ' :abbreviation ')
        (mtg-language-create :language ' :abbreviation ')
        )

  "Language metadata (abbreviations and endonyms).

`listp' of `mtg-language-p's:

‚Ä¢ each ‚Äò:language‚Äô should be in `mtg-language-list'."

  :type '(repeat (symbol :tag "Language Info"))

  :safe #'listp
  :group 'mtg)

==============================================

;; Package-Requires: ((emacs "25") (json "1.4"))

;;----------------------------------------------;;

(cl-defun make-mtg-symbol (&key symbol abbreviation (image nil) (char nil))

  "Make an `mtg-symbol'. 

A Smart Constructor ‚Äî validation & defaulting.

Inputs:

‚Ä¢ SYMBOL       ‚Äî a `symbolp'.
‚Ä¢ ABBREVIATION ‚Äî a `symbolp'.
‚Ä¢ IMAGE        ‚Äî an optional `imagep', or `symbolp' thereof.
‚Ä¢ CHAR         ‚Äî an optional `characterp', or `symbolp' thereof.

Examples:

‚Ä¢ M-: (make-mtg-symbol :symbol 'blue-mana :abbreviation 'u :char ?üå¢)
   ‚áí #s(mtg-symbol blue-mana u nil 127778)"

  (let* ((SYMBOL       symbol)
         (ABBREVIATION abbreviation)
         (IMAGE        image)
         (CHAR         char)
         )

  (mtg-symbol-create :symbol       SYMBOL
                     :abbreviation ABBREVIATION
                     :image        IMAGE
                     :char         CHAR)))

==============================================

(defun mtg-company (command &optional arg &rest _)

  "Company Backend for MTG Cards.

Inputs:

‚Ä¢ COMMAND ‚Äî a `symbolp'.
  The Company-Command.
‚Ä¢ ARG ‚Äî an `integerp'.
  A Prefix-Argument."

  (case command

    (interactive
     (company-begin-backend 'company-mtg))

    (init    
     (mtg-initialize-cards-by-name-table))

    (prefix
     (mtg-company-grab-card-name))

    (candidates
     ())

    (ignore-case
     'keep-prefix)))

==============================================


(defun mtg-company-grab-card-name ()

  "Grab the ‚Äòmtg-card-name‚Äô before `point'.

Idiomatic card names:

‚Ä¢ should (mostly) have capitalized words;
‚Ä¢ may include lowercase articles;
‚Ä¢ may have some punctuation characters (hyphen, apostrophe, colon).

If point is at the end of a word, return it.
Otherwise, if point is not inside a symbol, return an empty string."

  (pcase-let* ((BEG-POINT . END-POINT)
               (bounds-of-thing-at-point 'mtg-card-name))
    (POINT (point))
    (TEXT (buffer-substring BEG-POINT POINT))
    )


  (if (looking-at "\\>")

      (buffer-substring (point) (save-excursion (skip-backward mtg-syntax-card-name-charset-regexp) (point)))

    (unless (and (char-after) (eq (char-syntax (char-after)) ?w))

      "")))

  ()))

==============================================



(unless (bound-and-true-p mtg-cards-names-vector)

  (defvar mtg-cards-names-vector mtg-company-cards-names-vector

    "MTG Card Names (see `mtg-company-cards-names-vector')."))


==============================================

(defun mtg-company-initialize-card-names (force)

  "Initialize the MTG Card Name store.

Inputs:

‚Ä¢ FORCE ‚Äî a `booleanp'.

Effects:

‚Ä¢ Modifies `mtg-company-card-names-vector'."

  (let* ((INITIALIZE? (or force
                          (not (bound-and-true-p mtg-company-card-names-vector))))
         )

    (when INITIALIZE?
      ())))

==============================================


(defun mtg-company-card-names-trie ()

  "Return all (known/valid) MTG Cards Naes.

Output:

‚Ä¢ a `vectorp' of `stringp's."

  (if (bound-and-true-p mtg-card-names-vector)
      mtg-card-names-vector
    mtg-company-card-names-vector))

;;----------------------------------------------;;

(defun mtg-company-card-names-trie ()

  "Return all (known/valid) MTG Cards Naes.

Output:

‚Ä¢ a `vectorp' of `stringp's."

  (if (bound-and-true-p mtg-card-names-vector)
      mtg-card-names-vector
    mtg-company-card-names-vector))


;;----------------------------------------------;;

(defun mtg-company-complete-card-name (prefix)

  "Complete PREFIX as an MTG Card Name.

Inputs:

‚Ä¢ PREFIX ‚Äî a `stringp'.

Output:

‚Ä¢ a `listp' of `stringp's.

See:

‚Ä¢ thing ‚Äòmtg-card-name‚Äô."

  (let* ((PREFIX        (or prefix ""))
         (POSSIBILITIES (mtg-company-card-names))
         (CANDIDATES    (complete PREFIX POSSIBILITIES))
         )

    CANDIDATES))

==============================================

(cl-defun mtg-company/radix-tree/suffixes (trie prefix &key ignore-case)

  "Return a `radix-tree-p' from WORDS.

Inputs:

‚Ä¢ TRIE        ‚Äî a `radix-tree-p'.
‚Ä¢ PREFIX      ‚Äî a `stringp'.
‚Ä¢ IGNORE-CASE ‚Äî a `booleanp'.

Examples:

‚Ä¢ M-: (mtg-company/radix-tree/suffixes (mtg-company/radix-tree/from-seq (list \"application\" \"appetizer\" \"applicative\" \"apple\")) \"appli\" :ignore-case t)
    ‚Üí '(\"application\" \"applicative\")"

  (let* ((SET (make-hash-table))
         )

    (radix-tree-iter-mappings
     trie

     (lambda (k v)
       (message "%s ‚áí %s (%s)" k v prefix)
       (when (string-prefix-p prefix k ignore-case)
         (puthash k t SET)))

    (hash-table-keys SET))))

;; ^ M-: (mtg-company/radix-tree/suffixes (mtg-company/radix-tree/from-seq '("application" "appetizer" "applicative" "apple")) "appli" :ignore-case t)
;;     ‚áí '("application" "applicative")
;;
;;   M-: (string-prefix-p "appli" "application" t)
;;     ‚áí t
;;

==============================================

;;----------------------------------------------;;
;; Regexps -------------------------------------;;
;;----------------------------------------------;;

(defun mtg-card-name-character-regexp ()

  "Return a `regexpp' matching an ‚Äòmtg-card-name‚Äô character."

  (let* ((CHAR-REGEXP
          (rx-to-string `(char alpha digit ,@mtg-card-name-punctuation-characters-list) t))

         (WORD-REGEXP
          (rx-to-string `(1+ (regexp ,CHAR-REGEXP)) t))

         (PHRASE-REGEXP
          (rx-to-string `(1+ (word-start (regexp ,WORD-REGEXP) word-end))))
         )

    PHRASE-REGEXP))

==============================================

(defun mtg-card-name-regexp ()

  "Return a `regexpp' matching an ‚Äòmtg-card-name‚Äô.

For example, this command matches these ‚Äòmtg-card-name‚Äôs:

‚Ä¢ ‚ÄúEmpty the Warrens‚Äù
‚Ä¢ ‚ÄúBorrowing 100,000 Arrows‚Äù"

  (let* ((CHAR-REGEXP
          (rx-to-string `(char alpha digit ,@mtg-card-name-punctuation-characters-list) t))

         (ARTICLE-REGEXP
          (regexp-opt mtg-card-name-article-strings-list 'word))

         (WORD-REGEXP
          (rx-to-string `(or (regexp ,ARTICLE-REGEXP)
                             (and word-start
                                  (and (char upper digit)
                                       (0+ (regexp ,CHAR-REGEXP)))
                                  word-end))
                        t))

         (PHRASE-REGEXP
          (rx-to-string `(1+ (regexp ,WORD-REGEXP))))
         )

    PHRASE-REGEXP))

;; ^ M-: (mtg-card-name-regexp)
;;     ‚áí "\\(?:\\(?:\\(a\\(?:nd\\|[nst]\\)?\\|b\\(?:ut\\|y\\)\\|en\\|f\\(?:or\\|rom\\)\\|i\\(?:nto\\|[ln]\\)\\|o[fnr]\\|t\\(?:he\\|o\\)\\|upon\\|with\\)\\|\\<[[:upper:]][!\"',-.:?[:digit:][:alpha:]]*\\>\\)+\\)"

;; e.g. ‚Äòmtg-card-name‚Äôs:
;;
;; ‚Ä¢ card Ancestral Recall card
;; ‚Ä¢ card Looter il-Kor card
;; ‚Ä¢ card Borrowing 100,000 Arrows card
;; ‚Ä¢ card To Arms! card
;; ‚Ä¢ card Empty the Warrens card
;;
;; (re-search-backward "\\(?:\\(?:\\(a\\(?:nd\\|[nst]\\)?\\|b\\(?:ut\\|y\\)\\|en\\|f\\(?:or\\|rom\\)\\|i\\(?:nto\\|[ln]\\)\\|o[fnr]\\|t\\(?:he\\|o\\)\\|upon\\|with\\)\\|\\<[[:upper:]][!\"',-.:?[:digit:][:alpha:]]*\\>\\)+\\)")
;;

==============================================

(defconst mtg-table-list-format

  [("Name" mtg-longest-card-name-length t)
   ("" nil t)
   ("" nil t)
   ("" nil t)
   ("" nil t)
   ("" nil t)
   ("" nil t)
  ]

  "`tabulated-list-format' for `mtg-table-mode'.

a `vectorp' of `listp's of ¬´ (NAME WIDTH SORTER) ¬ª triplets.")

;;----------------------------------------------;;

(defcustom mtg-table-list-format-list

  nil

  "Table Format for `mtg-table-mode'.

a `listp' of columns (`symbolp's) and/or triplets (`listp's) with form:

    (NAME &optional WIDTH SORTER)

Ignored if nil, defaulting to `mtg-default-table-list-format'."

  :type '(repeat (list (string :tag "Column Name"
                               :options ())

                       (choice (integer   :tag "Minimum Column Width")
                               (const nil :tag "Don't Pad Column"))

                       (choice (function  :tag "Sort Column by Comparator")
                               (const t   :tag "Sort Column as String")
                               (const nil :tag "Don't Sort Column"))))

  :safe #'listp
  :group 'mtg)


;;----------------------------------------------;;

(cl-defun mtg-table/clean-text (text &key width)

  "Return TEXT as a valid Table Entry (for `tabulated-list-mode').

Inputs:

‚Ä¢ TEXT ‚Äî a `stringp'. 
‚Ä¢ WIDTH ‚Äî an `integerp' or nil. 

Transformations include:

‚Ä¢ Replace newlines with ‚Äú|‚Äù (i.e. a vertical bar).
‚Ä¢ Truncate to a `string-width' of WIDTH, with ‚Äú‚Ä¶‚Äù (i.e. ellipses)."

  (let* ((TEXT-ONELINE
          (string-join (split-string (string-trim text) "[\f\n\r\v]+" :omit-nulls) " | "))

         (TEXT-TRUNCATED
          (if (and width (natnump width))
              (let ((PADDING  nil)
                    (ELLIPSIS "‚Ä¶")
                    (COLUMN-END width)
                    (COLUMN-BEG 1)
                    )
                (truncate-string-to-width TEXT-ONELINE COLUMN-END COLUMN-BEG PADDING ELLIPSIS))
            TEXT-ONELINE))
         )

    TEXT-TRUNCATED))



==============================================

(cl-defun sboo-mtg-read-scryfall-json (&optional (filename mtg-card-names-file-json))

  "Read a JSON File of MTG cards (in the Scryfall card schema, circa 2019).

Inputs:

‚Ä¢ FILENAME ‚Äî a JSON File.

Output:

‚Ä¢ a set of `mtg-card's.

Example:

‚Ä¢ M-: (sboo-mtg-read-scryfall-json)
    ‚áí 

Links:

‚Ä¢ URL `https://scryfall.com/docs/api/cards'"

  (let* (
         )

    (json-read-file filename)))

==============================================



==============================================